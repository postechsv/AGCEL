load onethirdrule .
load ../../heuristic-search .

fmod AVALUE is
    sorts AValue AValue? .
    subsort AValue < AValue? .
    op nilAValue : -> AValue? .
    ops least rest : -> AValue .
endfm

fmod AOBJ is
    pr STEP .
    pr AVALUE .
    sort AObj .
    op aobj : Step AValue AValue? -> AObj [ctor] .
endfm

fmod ACONF is
    pr AOBJ .
    sort AConf .
    subsort AObj < AConf .
    op none : -> AConf [ctor] .
    op __ : AConf AConf -> AConf [ctor assoc comm id: none] .
    var O : AObj .
    eq O O = O .
endfm

mod ONETHIRDRULE-ABS is
    pr ONETHIRDRULE .
    inc ACONF .
    inc HEURISTIC-SEARCH .

    subsort Global < State .
    subsort AConf < AState .

    vars O O' : Oid . vars CF : Configuration . var C : Cid .
    vars OS OS' : OidSet . 
    var R TH N VA : Nat .
    var VS : ValueSet .
    vars V V' : Value .
    var D : Value? .
    var VM : VoteMap .
    var VOTE : Vote .
    var ATTS : AttributeSet .
    var ST : Step .
    var MSG : Msg .

    op aconf : Configuration Value -> AConf .
    op aval : Value? Value -> AValue .

    eq abst({TH, VS, OS, CF}) = aconf(CF, 0) . --- 0 is given as the least element

    eq aval(nilValue, V) = nilAValue .
    eq aval(V, V) = least .
    eq aval(V, V') = rest [owise] .

    eq aconf(< O : Node | status : [R, ST], value : V, decision : D, ATTS > CF, V')
      = aobj(ST, aval(V, V'), aval(D, V')) aconf(CF, V') .
    eq aconf(MSG CF, V') = aconf(CF, V') .
    eq aconf(none, V') = none .

    ---subsort OidSet ValueSet Configuration Vote VoteMap AttributeSet < Data .
    var DATA : Data .
    op unit : -> AData [ctor] .
    eq abst(DATA) = unit .

    --- prop def
    ops disagree : -> Prop [ctor] .
    eq { TH:Nat, VS:ValueSet, OS:OidSet, 
        < O:Oid : Node | status : [R:Nat, done], decision : 0, ATTR:AttributeSet >
        < O':Oid : Node | status : [R':Nat, done], decision : 1, ATTR':AttributeSet > 
        CONF:Configuration } |= disagree = true .
    eq S:State |= disagree  = false [owise] .
endm

mod ONETHIRDRULE-ANALYSIS is
    pr ONETHIRDRULE-ABS . ---NO-MSG-LOSS .

    protecting STRING .
    subsort String < Oid .

    ops obA obB obC obD obE obF : -> InitObject .
    ops init3 init4 init5a init5b init6 : -> Global .

    eq obA = < "A" : Node | status : [1, init], value : 0, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obB = < "B" : Node | status : [1, init], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obC = < "C" : Node | status : [1, init], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obD = < "D" : Node | status : [1, init], value : 0, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obE = < "E" : Node | status : [1, init], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obF = < "F" : Node | status : [1, init], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .

    eq init3 = {2, (0 ; 1), ("A" ; "B" ; "C"), (obA obB obC) } .
    eq init4 = {2, (0 ; 1), ("A" ; "B" ; "C" ; "D"), (obA obB obC obD) } .
    eq init5a = {3, (0 ; 1), ("A" ; "B" ; "C" ; "D" ; "E"), (obA obB obC obD obE) } . --- 2 (least) vs 3 (rest)
    eq init5b = {3, (0 ; 1), ("A" ; "B" ; "C" ; "E" ; "F"), (obA obB obC obE obF) } . --- 1 (least) vs 4 (rest)
    eq init6 = {4, (0 ; 1), ("A" ; "B" ; "C" ; "D" ; "E" ; "F"), (obA obB obC obD obE obF) } .
endm

---search [1] init3 =>* { TH:Nat, VS:ValueSet, OS:OidSet, < O:Oid : Node | status : [R:Nat, done], decision : 0, ATTR:AttributeSet > < O':Oid : Node | status : [R':Nat, done], decision : 1, ATTR':AttributeSet > CONF:Configuration } .
---search [1] init3 =>* X:State such that X:State |= disagree .



---red {2,0 ; 1, "A" ; "B" ; "C", < "A" : Node | status : [2, done],value : 0,decision : 0,votes : [0 |-> 2 ; 1 |-> 0,2] > < "B" : Node | status : [2, wait],value : 0,
---    decision : nil,votes : [0 |-> 1 ; 1 |-> 0,1] > < "C" : Node | status : [1, done],value : 1,decision : 1,votes : [0 |-> 0 ; 1 |-> 2,2] > (multicast vote(0, 1) from "A" to "C") (
---    multicast vote(0, 2) from "A" to "B" ; "C") (multicast vote(0, 2) from "B" to "C") multicast vote(1, 1) from "C" to "A" ; "B"} |= disagree . --- true
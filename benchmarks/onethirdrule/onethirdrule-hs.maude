load onethirdrule .
load ../../heuristic-search .

fmod AVALUE is
    pr VALUE .

    var N : Nat .

    sorts AValue AValue? .
    subsort AValue < AValue? .
    op nilAValue : -> AValue? .
    ops least rest : -> AValue .

    op abstValue : Value? -> AValue? .
    eq abstValue(nilValue) = nilAValue .
    eq abstValue(0) = least .
    eq abstValue(N) = rest [owise] .
endfm


fmod AROUND is
    pr NAT .

    var N : Nat .

    sort ARound .
    ops even odd : -> ARound .

    op next : ARound -> ARound .
    eq next(even) = odd .
    eq next(odd) = even .

    op abstRound : Nat -> ARound .
   ceq abstRound(N) = even if N rem 2 = 0 .
    eq abstRound(N) = odd [owise] .
endfm


fmod AVOTE-MAP is
    pr VOTE-MAP .
    pr AVALUE .

    var V : Value . var AV : AValue .
    var VM : VoteMap . var AVM : AVoteMap .
    var B : Bool . var N : Nat .

    sort AVoteMap .
    op none : -> AVoteMap [ctor] .
    op _|->_ : AValue Bool -> AVoteMap [ctor] .
    op _;_ : AVoteMap AVoteMap -> AVoteMap [ctor comm assoc id: none] .

    op initAVM : -> AVoteMap .
    eq initAVM = (least |-> false) ; (rest |-> false) .

    op set : AVoteMap AValue -> AVoteMap .
    eq set((AV |-> B) ; AVM, AV) = (AV |-> true) ; AVM .

    op abstVoteMap : VoteMap -> AVoteMap .
    eq abstVoteMap(V |-> N ; VM)
      = (abstValue(V) |-> (N > 0)) ; abstVoteMap(VM) .
    eq abstVoteMap(none) = none .
endfm


mod ACONF is
    pr ONETHIRDRULE .
    pr STEP .
    pr AROUND .  pr AVOTE-MAP .

    var O : Oid . var OS : OidSet .
    var N N' : Nat . var ST : Step .
    var V : Value . var D : Value? .
    var VM : VoteMap .
    var AO : AObj .
    var CF : Configuration .
    var ATTS : AttributeSet .

    sort AObj .
    op aobj : ARound Step AValue AValue? AVoteMap -> AObj [ctor] .

    sort AMsg .
    op amsg : AValue ARound -> AMsg [ctor] .

    sort AConf .
    subsorts AObj AMsg < AConf .
    op none : -> AConf [ctor] .
    op __ : AConf AConf -> AConf [ctor assoc comm id: none] .
    eq AO AO = AO .

    op abstConf : Configuration -> AConf .
    eq abstConf(< O : Node | status : [N, ST], value : V, decision : D, votes : [VM, N'], ATTS > CF)
      = aobj(abstRound(N), ST, abstValue(V), abstValue(D), abstVoteMap(VM))
        abstConf(CF) .
    eq abstConf((multicast vote(V,N) from O to OS) CF)
      = amsg(abstValue(V), abstRound(N)) abstConf(CF) .
    eq abstConf(none) = none .
endm


mod ONETHIRDRULE-ABS is
    pr ACONF .
    inc HEURISTIC-SEARCH .

    subsort Global < State .
    subsort AConf < AState .

    vars O O' : Oid . vars CF : Configuration . var C : Cid .
    vars OS OS' : OidSet . 
    var R TH N VA : Nat .
    var VS : ValueSet .
    vars V V' : Value .
    var D : Value? .
    var VM : VoteMap .
    var VOTE : Vote .
    var ST : Step .
    var MSG : Msg .
    var ATTS : AttributeSet .

    --- state abstraction
    eq abst({TH, VS, OS, CF}) = abstConf(CF) .

    --- action abstraction
    vars Q Q' : Qid . var DATA : Data .
    subsort AValue < AData .
    eq abst('vote, 'V, data(V)) = abstValue(V) .
    eq abst('receive, 'V, data(V)) = abstValue(V) .
    eq abst('decide, 'V, data(V)) = abstValue(V) .
    eq abst('update, 'V', data(V)) =  abstValue(V) . --- old value
    eq abst('update, 'V, data(V)) = abstValue(V) . --- new value
    eq abst(Q, Q', DATA) = -- [owise] .

    --- prop def
    op disagree : -> Prop [ctor] .
    eq { TH:Nat, VS:ValueSet, OS:OidSet, 
        < O:Oid : Node | status : [R:Nat, done], decision : 0, ATTR:AttributeSet >
        < O':Oid : Node | status : [R':Nat, done], decision : 1, ATTR':AttributeSet > 
        CONF:Configuration } |= disagree = true .
    eq S:State |= disagree  = false [owise] .

   op hasNil : -> Prop [ctor] .
    eq { TH:Nat, VS:ValueSet, OS:OidSet, 
        < O:Oid : Node | decision : nilValue, ATTR:AttributeSet >
        CONF:Configuration } |= hasNil = true .
    eq S:State |= hasNil  = false [owise] .

    op hasMsg : -> Prop [ctor] .
    eq { TH:Nat, VS:ValueSet, OS:OidSet,
        MSG CONF:Configuration } |= hasMsg = true .
    eq S:State |= hasMsg  = false [owise] .

    op decisionOf : Value Oid -> Prop .
    eq { TH:Nat, VS:ValueSet, OS:OidSet, 
        < O:Oid : Node | decision : D, ATTR:AttributeSet >
        CONF:Configuration } |= decisionOf(D,O) = true .
    eq S:State |= decisionOf(D,O) = false [owise] .
endm


mod ONETHIRDRULE-ASYS is --- abstract system for onethirdrule
    pr ONETHIRDRULE-ABS .

    vars V V' : AValue . vars D D' : AValue? .
    vars R R' : ARound . vars VM VM' : AVoteMap .
    vars ST ST' : Step . var S : AState .
    vars CF : AConf .
    vars SUBS SUBS' : ASubs .

    --- TODO migrate this to HEURISTIC-SEARCH
---    sort APair . --- abstract pair of AState x ASubs
---    op <_,_> : AState ASubs -> APair [ctor] .
---    op getAState : APair -> AState .
    eq getAState(< S, SUBS >) = S .
---    op getASubs : APair -> ASubs .
    eq getASubs(< S, SUBS >) = SUBS .

    --- stub for MaudeEnv.py
---    op abst : APair -> AState .
    eq abst(< S, SUBS >) = getAState(< S, SUBS >) .
---    op _|=_ : APair Prop -> Bool [frozen] .
    var P : Prop .
    eq < S, SUBS > |= P = S |= P .

    --- parity round, step, value, value?, votes flag 
    rl ['vote] :
    < aobj(R, init, V, nilAValue, VM) CF, SUBS >
    =>
    <
      aobj(R, wait, V, nilAValue, set(VM, V)) amsg(V, R) CF,
      ('R <- --) ; ('V <- V) ; ('O <- --) ; ('VOTE <- --) ; ('TH <- --) ; ('VS <- --) ; ('CF <- --) ; ('OS <- --) ; ('ATTS <- --)
    > .

    rl ['receive] : --- SCENARIO 1: some receive, others do not .
    < aobj(R, wait, V, nilAValue, VM) amsg(V', R) CF, SUBS >
    =>
    < aobj(R, wait, V, nilAValue, set(VM,V'))
      aobj(R, wait, V, nilAValue, VM)
      amsg(V', R) CF
    ,
      ('R <- --) ; ('V <- V') ; ('O <- --) ; ('VOTE <- --) ; ('TH <- --) ; ('VS <- --) ; ('CF <- --) ; ('OS <- --) ; ('ATTS <- --) ; ('O' <- --) ; ('OS' <- --)
    > .

    rl ['receive] : --- SCENARIO 2: all receive.
    < aobj(R, wait, V, nilAValue, VM) amsg(V', R) CF, SUBS >
    =>
    < aobj(R, wait, V, nilAValue, set(VM, V')) CF
    ,
      ('R <- --) ; ('V <- V') ; ('O <- --) ; ('VOTE <- --) ; ('TH <- --) ; ('VS <- --) ; ('CF <- --) ; ('OS <- --) ; ('ATTS <- --) ; ('O' <- --) ; ('OS' <- --)
    > .

    rl ['decide] :
    < aobj(R, wait, V, nilAValue, (V' |-> true) ; VM) CF, SUBS >
    =>
    < aobj(R, wait, V, V', (V' |-> true) ; VM) CF,
      ('N <- --) ; ('R <- --) ; ('V <- V') ; ('O <- --) ; ('TH <- --) ; ('VM <- --) ; ('VS <- --) ; ('CF <- --) ; ('OS <- --) ; ('ATTS <- --) ; ('VA <- --)
    > .

    rl ['update] :
    < aobj(R, wait, V, nilAValue, (V' |-> true) ; VM) CF, SUBS >
    =>
    < aobj(next(R), init, V', nilAValue, initAVM) CF,
      ('N <- --) ; ('R <- --) ; ('V <- V) ; ('O <- --) ; ('TH <- --) ; ('VM <- --) ; ('VS <- --) ; ('V' <- V') ; ('CF <- --) ; ('OS <- --) ; ('ATTS <- --) ; ('VA <- --)
    > .

    rl ['loss] : 
    < amsg(V, R) CF, SUBS >
    =>
    < CF,
      ('TH <- --) ; ('VS <- --) ; ('CF <- --) ; ('MSG <- --) ; ('OS <- --)
    > .


     --- disagree on astates
    eq aobj(R, ST, V, least, VM)
       aobj(R', ST', V', rest, VM)
       CF |= disagree = true .
    eq S |= disagree = false [owise] . 
endm


mod ONETHIRDRULE-HSYS is --- heuristic system for onethirdrule
  pr ONETHIRDRULE-ASYS .


  var ST : State .  var AST : AState .  var HST : HState .  var AP : APair .
  var ACT : Act .  var AACT : AAct .  var HACT : HAct .
  var AR : ARound .  var STEP : Step .  vars AV AV' : AValue .
  var AD : AValue? .  var AVM : AVoteMap .  var ACF : AConf .

---  sorts HState HAct .
---  op heur : AState -> HState .  op heur : State -> HState .  op heur : APair -> HState .
---  op heur : AAct -> HAct .  op heur : Act -> HAct .
  eq heur(ST) = heur(abst(ST)) .
  eq heur(ACT) = heur(abst(ACT)) .
  eq heur(AP) = heur(getAState(AP)) .

  --- Define HState
  op none : -> HState [ctor] .
  op hobj : Step AValue -> HState [ctor] .
  op __ : HState HState -> HState [ctor assoc comm id: none] .
  eq HST HST = HST .

  --- Define heur : AState -> HState
  eq heur(aobj(AR, STEP, AV, AD, AVM) ACF) = hobj(STEP, AV) heur(ACF) .
  eq heur(amsg(AV, AR) ACF) = heur(ACF) .
  eq heur(none) = none .

  --- Define HAct
  op hactVote : AValue -> HAct [ctor] .
  op hactReceive : AValue -> HAct [ctor] .
  op hactUpdate : AValue AValue -> HAct [ctor] .
  op hactDecide : AValue -> HAct [ctor] .
  op hactLoss : -> HAct [ctor] .

  --- Define heur : AAct -> HAct
  eq heur(aact('vote, ('R <- --) ; ('V <- AV) ; ('O <- --) ; ('VOTE <- --) ; ('TH <- --) ; ('VS <- --) ; ('CF <- --) ; ('OS <- --) ; ('ATTS <- --)))
    = hactVote(AV) .
  eq heur(aact('receive, ('R <- --) ; ('V <- AV) ; ('O <- --) ; ('VOTE <- --) ; ('TH <- --) ; ('VS <- --) ; ('CF <- --) ; ('OS <- --) ; ('ATTS <- --) ; ('O' <- --) ; ('OS' <- --)))
    = hactReceive(AV) .
  eq heur(aact('update, ('N <- --) ; ('R <- --) ; ('V <- AV) ; ('O <- --) ; ('TH <- --) ; ('VM <- --) ; ('VS <- --) ; ('V' <- AV') ; ('CF <- --) ; ('OS <- --) ; ('ATTS <- --) ; ('VA <- --)))
    = hactUpdate(AV, AV') .
  eq heur(aact('decide, ('N <- --) ; ('R <- --) ; ('V <- AV) ; ('O <- --) ; ('TH <- --) ; ('VM <- --) ; ('VS <- --) ; ('CF <- --) ; ('OS <- --) ; ('ATTS <- --) ; ('VA <- --)))
    = hactDecide(AV) .
  eq heur(aact('loss, ('TH <- --) ; ('VS <- --) ; ('CF <- --) ; ('MSG <- --) ; ('OS <- --)))
    = hactLoss .
endm


mod ONETHIRDRULE-ANALYSIS is
    pr ONETHIRDRULE-HSYS . ---NO-MSG-LOSS .

    protecting STRING .
    subsort String < Oid .

    ops obA obB obC obD obE obF : -> InitObject .
    ops init3 init4 init5a init5b init6 : -> Global .
    ops init3APair : -> APair .

    eq obA = < "A" : Node | status : [1, init], value : 0, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obB = < "B" : Node | status : [1, init], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obC = < "C" : Node | status : [1, init], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obD = < "D" : Node | status : [1, init], value : 0, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obE = < "E" : Node | status : [1, init], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obF = < "F" : Node | status : [1, init], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .

    eq init3 = {2, (0 ; 1), ("A" ; "B" ; "C"), (obA obB obC) } .
    eq init3APair = < abst(init3), none > .
    eq init4 = {2, (0 ; 1), ("A" ; "B" ; "C" ; "D"), (obA obB obC obD) } .
    eq init5a = {3, (0 ; 1), ("A" ; "B" ; "C" ; "D" ; "E"), (obA obB obC obD obE) } . --- 2 (least) vs 3 (rest)
    eq init5b = {3, (0 ; 1), ("A" ; "B" ; "C" ; "E" ; "F"), (obA obB obC obE obF) } . --- 1 (least) vs 4 (rest)
    eq init6 = {4, (0 ; 1), ("A" ; "B" ; "C" ; "D" ; "E" ; "F"), (obA obB obC obD obE obF) } .
endm

---search [1] init3APair =>* < X:AState, SUBS:ASubs > such that X:AState |= disagree .

---search [1] init3 =>* { TH:Nat, VS:ValueSet, OS:OidSet, < O:Oid : Node | status : [R:Nat, done], decision : 0, ATTR:AttributeSet > < O':Oid : Node | status : [R':Nat, done], decision : 1, ATTR':AttributeSet > CONF:Configuration } .
---search [1] init3 =>* X:State such that X:State |= disagree .

---red {2,0 ; 1, "A" ; "B" ; "C", < "A" : Node | status : [2, done],value : 0,decision : 0,votes : [0 |-> 2 ; 1 |-> 0,2] > < "B" : Node | status : [2, wait],value : 0,
---    decision : nil,votes : [0 |-> 1 ; 1 |-> 0,1] > < "C" : Node | status : [1, done],value : 1,decision : 1,votes : [0 |-> 0 ; 1 |-> 2,2] > (multicast vote(0, 1) from "A" to "C") (
---    multicast vote(0, 2) from "A" to "B" ; "C") (multicast vote(0, 2) from "B" to "C") multicast vote(1, 1) from "C" to "A" ; "B"} |= disagree . --- true

load ../../tool2 .
load onethirdrule .

mod MODEL is
    pr ONETHIRDRULE-NO-MSG-LOSS .
    inc SATISFACTION .
    inc OBSERVATION .

    protecting STRING .
    subsort String < Oid .

    subsort Global < State .

    vars O O' : Oid . vars CF : Configuration . var C : Cid .
    vars OS OS' : OidSet . 
    var R TH N VA : Nat .
    var VS : ValueSet .
    var S : State .
    var MSG : Msg .
    vars ATTS ATTS' : AttributeSet .
    vars V V' : Value .
    var VM : VoteMap .
    var VOTE : Vote .

    op disagree : -> Prop [ctor] .
    eq { TH, VS, OS, < O : Node | decision : 0, ATTS > < O' : Node | decision : 1, ATTS' > CF } |= disagree = true .
    eq S |= disagree = false [owise] .

    op voteLHS : Value -> Prop [ctor] .
    eq {TH, V ; VS, O ; OS,
        < O : Node | status : [R, start], value : V, decision : nilValue, votes : VOTE, ATTS > 
        CF
    } |= voteLHS(V) = true .
    eq S |= voteLHS(V) = false [owise] .

    op receiveLHS : Value -> Prop [ctor] .
    eq {TH, V ; VS, OS,
        < O : Node | status : [R, wait], decision : nilValue, votes : VOTE, ATTS > 
        (multicast vote(V, R) from O' to (O ; OS'))
        CF
    } |= receiveLHS(V) = true .
    eq S |= receiveLHS(V) = false [owise] .

    op decideLHS : Value -> Prop [ctor] .
   ceq {TH, VS, OS,
        < O : Node | status : [R, wait], decision : nilValue, votes : [(V |-> N ; VM), VA], ATTS > 
        CF
    } |= decideLHS(V) = true if TH <= N .
    eq S |= decideLHS(V) = false [owise] .

    op updateLHS : Value Value -> Prop [ctor] .
   ceq {TH, V' ; VS, OS,
        < O : Node | status : [R, wait], value : V, decision : nilValue, votes : [V' |-> N ; VM, VA], ATTS >
        CF
    } |= updateLHS(V, V') = true if (N < TH) and (TH <= VA) and genConst(V', N, VM, VS) .
    eq S |= updateLHS(V, V') = false [owise] .

    --- Focus IDs ---
    --- ops f1 f2 : -> Oid .
    --- eq f1 = "A" .  eq f2 = "B" .

    --- Focus/Star LHS Propositions ---
    ops voteLHSF1 voteLHSF2 voteLHSStar : Value -> Prop [ctor] .
    eq {TH, V ; VS, "A" ; OS,
        < "A" : Node | status : [R, start], value : V, decision : nilValue, votes : VOTE, ATTS > 
        CF
    } |= voteLHSF1(V) = true .
    eq S |= voteLHSF1(V) = false [owise] .

    eq {TH, V ; VS, "B" ; OS,
        < "B" : Node | status : [R, start], value : V, decision : nilValue, votes : VOTE, ATTS > 
        CF
    } |= voteLHSF2(V) = true .
    eq S |= voteLHSF2(V) = false [owise] .

    ceq {TH, V ; VS, O ; OS,
        < O : Node | status : [R, start], value : V, decision : nilValue, votes : VOTE, ATTS > 
        CF
    } |= voteLHSStar(V) = true if O =/= "A" and O =/= "B" .
    eq S |= voteLHSStar(V) = false [owise] .

    ops receiveLHSF1 receiveLHSF2 receiveLHSStar : Value -> Prop [ctor] .
    eq {TH, V ; VS, OS,
        < "A" : Node | status : [R, wait], decision : nilValue, votes : VOTE, ATTS > 
        (multicast vote(V, R) from O' to ("A" ; OS'))
        CF
    } |= receiveLHSF1(V) = true .
    eq S |= receiveLHSF1(V) = false [owise] .

    eq {TH, V ; VS, OS,
        < "B" : Node | status : [R, wait], decision : nilValue, votes : VOTE, ATTS > 
        (multicast vote(V, R) from O' to ("B" ; OS'))
        CF
    } |= receiveLHSF2(V) = true .
    eq S |= receiveLHSF2(V) = false [owise] .

    ceq {TH, V ; VS, OS,
        < O : Node | status : [R, wait], decision : nilValue, votes : VOTE, ATTS > 
        (multicast vote(V, R) from O' to (O ; OS'))
        CF
    } |= receiveLHSStar(V) = true if O =/= "A" and O =/= "B" .
    eq S |= receiveLHSStar(V) = false [owise] .

    ops decideLHSF1 decideLHSF2 decideLHSStar : Value -> Prop [ctor] .
   ceq {TH, VS, OS,
        < "A" : Node | status : [R, wait], decision : nilValue, votes : [(V |-> N ; VM), VA], ATTS > 
        CF
    } |= decideLHSF1(V) = true if TH <= N .
    eq S |= decideLHSF1(V) = false [owise] .

   ceq {TH, VS, OS,
        < "B" : Node | status : [R, wait], decision : nilValue, votes : [(V |-> N ; VM), VA], ATTS > 
        CF
    } |= decideLHSF2(V) = true if TH <= N .
    eq S |= decideLHSF2(V) = false [owise] .

   ceq {TH, VS, OS,
        < O : Node | status : [R, wait], decision : nilValue, votes : [(V |-> N ; VM), VA], ATTS > 
        CF
    } |= decideLHSStar(V) = true if O =/= "A" and O =/= "B" and TH <= N .
    eq S |= decideLHSStar(V) = false [owise] .

    ops updateLHSF1 updateLHSF2 updateLHSStar : Value Value -> Prop [ctor] .
   ceq {TH, V' ; VS, OS,
        < "A" : Node | status : [R, wait], value : V, decision : nilValue, votes : [V' |-> N ; VM, VA], ATTS >
        CF
    } |= updateLHSF1(V, V') = true if (N < TH) and (TH <= VA) and genConst(V', N, VM, VS) .
    eq S |= updateLHSF1(V, V') = false [owise] .

   ceq {TH, V' ; VS, OS,
        < "B" : Node | status : [R, wait], value : V, decision : nilValue, votes : [V' |-> N ; VM, VA], ATTS >
        CF
    } |= updateLHSF2(V, V') = true if (N < TH) and (TH <= VA) and genConst(V', N, VM, VS) .
    eq S |= updateLHSF2(V, V') = false [owise] .

   ceq {TH, V' ; VS, OS,
        < O : Node | status : [R, wait], value : V, decision : nilValue, votes : [V' |-> N ; VM, VA], ATTS >
        CF
    } |= updateLHSStar(V, V') = true if O =/= "A" and O =/= "B" and (N < TH) and (TH <= VA) and genConst(V', N, VM, VS) .
    eq S |= updateLHSStar(V, V') = false [owise] .

    --- Defining Observations ---
    eq obs(S) = < obsUpto(S,
        voteLHSF1(0) ; voteLHSF1(1) ; voteLHSF2(0) ; voteLHSF2(1) ; voteLHSStar(0) ; voteLHSStar(1) ;
        receiveLHSF1(0) ; receiveLHSF1(1) ; receiveLHSF2(0) ; receiveLHSF2(1) ; receiveLHSStar(0) ; receiveLHSStar(1) ;
        decideLHSF1(0) ; decideLHSF1(1) ; decideLHSF2(0) ; decideLHSF2(1) ; decideLHSStar(0) ; decideLHSStar(1) ;
        updateLHSF1(0, 0) ; updateLHSF1(0, 1) ; updateLHSF1(1, 0) ; updateLHSF1(1, 1) ;
        updateLHSF2(0, 0) ; updateLHSF2(0, 1) ; updateLHSF2(1, 0) ; updateLHSF2(1, 1) ;
        updateLHSStar(0, 0) ; updateLHSStar(0, 1) ; updateLHSStar(1, 0) ; updateLHSStar(1, 1) ;
        disagree ) > .

    eq reward(< FV:FeatVec , (disagree : true) , FV':FeatVec >) = 1.0 .
    eq reward(MS:MDPState) = 0.0 [owise] .
    var P : Prop . var B : Bool .
    eq < FV:FeatVec , (P : B) , FV':FeatVec > |= P = B .
endm


mod ONETHIRDRULE-TEST is
    protecting MODEL .
    protecting STRING .
    subsort String < Oid .
    
    op goal : -> Prop .
    eq goal = disagree .

    ops obA obB obC obD obE obF obG obH : -> InitObject .
    ops init3 init4 init5a init5b init5c init6a init6b init7a init7b init : -> Global .

    eq obA = < "A" : Node | status : [1, start], value : 0, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obB = < "B" : Node | status : [1, start], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obC = < "C" : Node | status : [1, start], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obD = < "D" : Node | status : [1, start], value : 0, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obE = < "E" : Node | status : [1, start], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obF = < "F" : Node | status : [1, start], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obG = < "G" : Node | status : [1, start], value : 1, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .
    eq obH = < "H" : Node | status : [1, start], value : 0, decision : nilValue, votes : [(0 |-> 0 ; 1 |-> 0),0] > .

    eq init3 = {2, (0 ; 1), ("A" ; "B" ; "C"), (obA obB obC) } .
    eq init4 = {2, (0 ; 1), ("A" ; "B" ; "C" ; "D"), (obA obB obC obD) } .
    eq init5a = {3, (0 ; 1), ("A" ; "B" ; "C" ; "D" ; "E"), (obA obB obC obD obE) } .
    eq init5b = {3, (0 ; 1), ("A" ; "B" ; "C" ; "E" ; "F"), (obA obB obC obE obF) } .
    eq init5c = {2, (0 ; 1), ("A" ; "B" ; "C" ; "D" ; "E"), (obA obB obC obD obE) } .
    eq init6a = {3, (0 ; 1), ("A" ; "B" ; "C" ; "D" ; "E" ; "F"), (obA obB obC obD obE obF) } .
    eq init6b = {4, (0 ; 1), ("A" ; "B" ; "C" ; "D" ; "E" ; "F"), (obA obB obC obD obE obF) } .
    eq init7a = {3, (0 ; 1), ("A" ; "B" ; "C" ; "D" ; "E" ; "F" ; "H"), (obA obB obC obD obE obF obH) } .
    eq init7b = {4, (0 ; 1), ("A" ; "B" ; "C" ; "D" ; "E" ; "F" ; "H"), (obA obB obC obD obE obF obH) } .

    --- init3
    --- eq init = init3 .

    --- init4
    --- eq init = init4 .

    --- init5a
    --- eq init = init5a .

    --- init5b
    eq init = init5b .

    --- init5c
    --- eq init = init5c .
endm


---search [1] init =>* X:State such that X:State |= goal .
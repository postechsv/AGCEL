fmod HEURISTIC-SEARCH is
  pr QID .
  pr META-LEVEL .

  var Q : Qid . var X : Variable .
  var T : Term . var SUBS : Substitution .

  --- STATE ABSTRACTION
  sorts State AState .
  op init : -> State .
  op error : -> [State] .
  op abst : State -> AState .

  --- DATA ABSTRACTION
  sorts Data AData .
  op data : Universal -> Data [ctor poly (1)] .
  op error : -> Data .
  op -- : -> AData [ctor] . --- symbol for don't care
  --- Label x Var Name x Data -> AData
  op abst : Qid Variable Data -> AData . --- data abstraction

  --- SUBSTITUTION ABSTRACTION
  sort ASubs .
  op none : -> ASubs [ctor] .
  op _<-_ : Qid AData -> ASubs [ctor] . --- TODO: maybe replace Qid -> Variable
  op _;_ : ASubs ASubs -> ASubs [ctor assoc comm id: none] .
  --- defined as the natural extension of data abstraction
  --- Label x Subs -> ASubs
  op abst : Qid Substitution -> ASubs . --- substitution abstraction
  eq abst(Q, (X <- T) ; SUBS)
    = (getName(X) <- abst(Q, X, downTerm('data[T], (error).Data))) ; abst(Q, SUBS) .
  eq abst(Q, none) = none .

  --- ACTION ABSTRACTION
  sorts Act AAct .
  op eps : -> Act [ctor] .
  op act : Qid Substitution -> Act [ctor] .
  op aact : Qid ASubs -> AAct [ctor] .
  op abst : Act -> AAct . --- action abstraction
  eq abst(act(Q, SUBS))
    = aact(Q, abst(Q, SUBS)) .

  --- for goals
  sorts Prop .
  op _|=_ : State Prop -> Bool [frozen] .
endfm


fmod TRACE is
  pr HEURISTIC-SEARCH .
  sort ResultTrace .
  op nil : -> ResultTrace [ctor] .
  op state : State -> ResultTrace [ctor] .
  op _===>_ : ResultTrace ResultTrace -> ResultTrace [ctor assoc id: nil] .
endfm


fmod SEARCH-BASE is
  pr HEURISTIC-SEARCH .
  pr TRACE .

  sort SearchCtx . --- e.g. timestamp, depth, etc. for each term
  --- # of States Explored, depth, parent state, applied action 
  op ctx : Nat Nat Term Act -> SearchCtx [ctor] .
  op initCtx : -> SearchCtx .
  eq initCtx = ctx(0,0,upTerm(init),eps) .
  --- TODO: previous action, etc (for debugging purposes)
  vars N D P : Nat . vars T T' : Term . vars A A' : Act .
  var CTX : SearchCtx .

  op getNStates : SearchCtx -> Nat .
  eq getNStates(ctx(N,D,T,A)) = N .
  op getDepth : SearchCtx -> Nat .
  eq getDepth(ctx(N,D,T,A)) = D .
  op getParent : SearchCtx -> Term .
  eq getParent(ctx(N,D,T,A)) = T .
  op getAction : SearchCtx -> Act .
  eq getAction(ctx(N,D,T,A)) = A .

  op updateCtx : SearchCtx Term Act -> SearchCtx .
  eq updateCtx(ctx(N,D,T,A),T',A') = ctx(N + 1,D + 1,T',A') . --- TODO : Fix N + 1
endfm


fmod SCORE is
  pr SEARCH-BASE .
  sort Score .
  op default : -> Score .
  op score : State Act SearchCtx -> Score .
  op score : AState AAct SearchCtx -> Score .
  ops _gt_ _lt_ _le_ : Score Score -> Bool .
  
  eq default gt default = false .
  eq default lt default = false .
  eq default le default = true . 
endfm


fmod BFS-SCORE is
  pr SCORE . pr NAT .
  subsort Nat < Score .
  var S : State . var A : Act .
  var CTX : SearchCtx .
  vars N N' : Nat .
  eq score(S, A, CTX) = getNStates(CTX) .
  eq N gt N' = N > N' .
  eq N lt N' = N < N' .
  eq N le N' = N <= N' .
endfm


fmod DFS-SCORE is
  pr SCORE . pr NAT .
  subsort Nat < Score .
  var S : State . var A : Act .
  var CTX : SearchCtx .
  vars N N' : Nat .
  eq score(S, A, CTX) = getNStates(CTX) .

  eq N gt N' = N < N' .
  eq N lt N' = N > N' .
  eq N le N' = N >= N' .  
endfm


fmod QHS-SCORE-BASE is
  inc SCORE . pr FLOAT .
  subsort Float < Score .

  var S : State . var A : Act .
  var AS : AState . var AA : AAct .
  var CTX : SearchCtx .
  vars F F' : Float .

  op qtable : AState AAct -> Float .
  eq score(S, A, CTX) = qtable(abst(S), abst(A)) .
  --- negation
  eq F gt F' = F < F' .
  eq F lt F' = F > F' .
  eq F le F' = F >= F' .
endfm


fmod CONST-SCORE is
  pr SCORE . pr NAT .
  subsort Nat < Score .
  var S : State . var A : Act .
  var CTX : SearchCtx .
  eq score(S, A, CTX) = default .
endfm

fmod HEURISTIC-SEARCH is
  pr QID .
  pr META-LEVEL .

  var Q : Qid . var X : Variable .
  var T : Term . var SUBS : Substitution .

  --- STATE ABSTRACTION
  sorts State AState .
  op init : -> State .
  op error : -> [State] .
  op abst : State -> AState .

  --- DATA ABSTRACTION
  sorts Data AData .
  op data : Universal -> Data [ctor poly (1)] .
  op error : -> Data .
  op adata : Universal -> AData [ctor poly (1)] .
  op -- : -> AData [ctor] . --- symbol for don't care
  --- Label x Var Name x Data -> AData
  op abst : Qid Qid Data -> AData . --- data abstraction

  --- SUBSTITUTION ABSTRACTION
  sort ASubs .
  op none : -> ASubs [ctor] .
  op _<-_ : Qid AData -> ASubs [ctor] . --- TODO: maybe replace Qid -> Variable
  op _;_ : ASubs ASubs -> ASubs [ctor assoc comm id: none] .
  --- defined as the natural extension of data abstraction
  --- Label x Subs -> ASubs
  var ADATA : AData .
  op abst : Qid Substitution -> ASubs . --- substitution abstraction
  ---eq abst(Q, (X <- T) ; SUBS)
  ---  = (getName(X) <- abst(Q, getName(X), downTerm('data[T], (error).Data))) ; abst(Q, SUBS) . --- TODO: if abst(...) = -- then skip
  ceq abst(Q, (X <- T) ; SUBS)
    = (getName(X) <- ADATA) ; abst(Q, SUBS)
    if ADATA := abst(Q, getName(X), downTerm('data[T], (error).Data))
    /\ ADATA =/= -- .
  eq abst(Q, (X <- T) ; SUBS) = abst(Q, SUBS) [owise] .
  eq abst(Q, none) = none .

  --- ACTION ABSTRACTION
  sorts Act AAct .
  op eps : -> Act [ctor] .
  op act : Qid Substitution -> Act [ctor] .
  op eps : -> AAct [ctor] .
  op aact : Qid ASubs -> AAct [ctor] .
  op abst : Act -> AAct . --- action abstraction
  eq abst(act(Q, SUBS))
    = aact(Q, abst(Q, SUBS)) .

  --- for goals TODO : integrate with model-checker.maude
  sorts Prop .
  op _|=_ : State Prop -> Bool [frozen] .
  op _|=_ : AState Prop -> Bool [frozen] .
  op _|=_ : HState Prop -> Bool [frozen] .
  op _/\_ : Prop Prop -> Prop [ctor assoc] .
  op ~_ : Prop -> Prop [ctor] .

  var S : State . vars P P1 P2 : Prop .
  eq S |= P1 /\ P2 = S |= P1 and S |= P2 .
  eq S |= ~ P = not S |= P .

  sort Props .
  subsort Prop < Props .
  op none : -> Props [ctor] .
  op _;_ : Props Props -> Props [ctor assoc id: none] .

  --- partial migration from ONETHIRDRULE-ASYS
  sort APair . --- abstract pair of AState x ASubs
  op <_,_> : AState AAct -> APair [ctor] .
  op getAState : APair -> AState .
  ---eq getAState(< S, A >) = S .
  op getAAct : APair -> AAct .
  ---eq getAAct(< S, A >) = A .
  op abst : APair -> AState . --- stub for MaudeEnv.py
  ---eq abst(< S, A >) = S .
  op _|=_ : APair Prop -> Bool [frozen] .

  op toAPair : State -> APair .
  eq toAPair(S) = < abst(S), eps > .

  --- partial migration from ONETHIRDRULE-HSYS
  sorts HState HAct .
  op heur : AState -> HState .  op heur : State -> HState .  op heur : APair -> HState .
  op heur : AAct -> HAct .  op heur : Act -> HAct .
endfm


fmod TRACE is
  pr HEURISTIC-SEARCH .
  sort ResultTrace .
  op nil : -> ResultTrace [ctor] .
  op state : State -> ResultTrace [ctor] .
  op _===>_ : ResultTrace ResultTrace -> ResultTrace [ctor assoc id: nil] .
endfm


fmod SEARCH-BASE is
  pr HEURISTIC-SEARCH .
  pr TRACE .

  sort SearchCtx . --- e.g. timestamp, depth, etc. for each term
  --- # of States Explored, depth, parent state, applied action 
  op ctx : Nat Nat Term Act -> SearchCtx [ctor] .
  op initCtx : -> SearchCtx .
  eq initCtx = ctx(0,0,upTerm(init),eps) .
  --- TODO: previous action, etc (for debugging purposes)
  vars N D P : Nat . vars T T' : Term . vars A A' : Act .
  var CTX : SearchCtx .

  op getNStates : SearchCtx -> Nat .
  eq getNStates(ctx(N,D,T,A)) = N .
  op getDepth : SearchCtx -> Nat .
  eq getDepth(ctx(N,D,T,A)) = D .
  op getParent : SearchCtx -> Term .
  eq getParent(ctx(N,D,T,A)) = T .
  op getAction : SearchCtx -> Act .
  eq getAction(ctx(N,D,T,A)) = A .

  op updateCtx : SearchCtx Term Act -> SearchCtx .
  eq updateCtx(ctx(N,D,T,A),T',A') = ctx(N + 1,D + 1,T',A') . --- TODO : Fix N + 1
endfm


fmod SCORE is
  pr SEARCH-BASE .
  sorts DScore Score .
  subsort DScore < Score .
  op default : -> DScore .
  op score : State Act SearchCtx -> Score .
  op score : AState AAct SearchCtx -> Score .
  ops _gt_ _lt_ _le_ : Score Score -> Bool .
  
  eq default gt default = false .
  eq default lt default = false .
  eq default le default = true . 

  var SC : Score .
  --- default is the last score to be popped
  eq default gt SC = true .
  eq SC gt default = false .
  eq default lt SC = false .
  eq SC lt default = true .
  eq default le SC = false .
  eq SC le default = true .
endfm


fmod BFS-SCORE is
  pr SCORE . pr NAT .
  subsort Nat < Score .
  var S : State . var A : Act .
  var CTX : SearchCtx .
  vars N N' : Nat .
  eq score(S, A, CTX) = getNStates(CTX) .
  eq N gt N' = N > N' .
  eq N lt N' = N < N' .
  eq N le N' = N <= N' .
endfm


fmod DFS-SCORE is
  pr SCORE . pr NAT .
  subsort Nat < Score .
  var S : State . var A : Act .
  var CTX : SearchCtx .
  vars N N' : Nat .
  eq score(S, A, CTX) = getNStates(CTX) .

  eq N gt N' = N < N' .
  eq N lt N' = N > N' .
  eq N le N' = N >= N' .  
endfm


fmod QHS-SCORE-BASE is
  inc SCORE . pr FLOAT .
  subsort Float < Score .

  var S : State . var A : Act .
  var CTX : SearchCtx .
  vars F F' : Float .

  op qtable : HState AAct -> Float .
  eq score(S, A, CTX) = qtable(heur(S), abst(A)) .

  --- correct qhs
  eq F gt F' = F < F' .
  eq F lt F' = F > F' .
  eq F le F' = F >= F' .

  --- reverse qhs
  ---eq F gt F' = F > F' .
  ---eq F lt F' = F < F' .
  ---eq F le F' = F <= F' .
endfm


fmod PROP-SCORE-BASE is
  inc SCORE . pr FLOAT .
  subsort Float < Score .

  var S : State . var A : Act .
  var HS : HState . var AA : AAct .
  var P : Prop . var PL : Props .
  var CTX : SearchCtx .
  vars F F' : Float .

  op props : -> Props .

  --- def score(S,A)
  eq score(S, A, CTX) = score(heur(S), abst(A), props) .

  --- def score(HS, AA, PL)
  op score : HState AAct Props -> Score .
  eq score(HS, AA, none) = default . --- start from bot
  ceq score(HS, AA, P ; PL) = score(P, AA) \/ score(HS, AA, PL) if HS |= P . --- join
  eq score(HS, AA, P ; PL) = score(HS, AA, PL) [owise] .

  --- def score(P, AA) : should be defined in the extended module
  op score : Prop AAct -> Score .

  --- score ordering
  eq F gt F' = F < F' .
  eq F lt F' = F > F' .
  eq F le F' = F >= F' .

  --- score join
  op _\/_ : Score Score -> Score .
  eq F \/ F' = max(F, F') .
  eq default \/ F = F .
  eq F \/ default = F .
  eq default \/ default = default .
endfm


fmod CONST-SCORE is
  pr SCORE . pr NAT .
  subsort Nat < Score .
  var S : State . var A : Act .
  var CTX : SearchCtx .
  eq score(S, A, CTX) = default .
endfm

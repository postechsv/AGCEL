---load heuristic-search.maude
load q-item.maude

fmod TERM-SET is
  pr META-TERM .
  sort TermSet .

  var T : Term . var TS : TermSet .

  op termElt : Term -> TermSet [ctor] .
  op mtTerm : -> TermSet [ctor] .
  op _;_ : TermSet TermSet -> TermSet [ctor assoc comm id: mtTerm] .
  eq termElt(T) ; termElt(T) = termElt(T) .

  op _in_ : Term TermSet -> Bool .
  eq T in (termElt(T) ; TS) = true .
  eq T in TS = false [owise] .
endfm


fmod LABEL-LIST is
  pr QID .
  sort Label LabelList .
  subsort Label < LabelList .
  op labelElt : Qid -> Label [ctor] .
  op nilLabel : -> LabelList [ctor] .
  op __ : LabelList LabelList -> LabelList [ctor assoc id: nilLabel] .
endfm


fmod SEARCH is
  pr META-LEVEL .
  pr SCORE .
  pr TERM-SET .
  pr LEFTIST-TREES{QItem<=} .
  pr SET{QItem} *
    (op _,_ : Set{QItem} Set{QItem} -> Set{QItem} to _;_) .
  pr LABEL-LIST .

  vars M : Module .
  vars T T' : Term .
  var P : Prop .
  vars N N' : Nat .
  vars QUE : LTree{QItem<=} .
  vars NQUE : NeLTree{QItem<=} .
  vars SC : Score .
  vars ITEM : QItem .
  vars ITEMS : Set{QItem} .
  var VIS : TermSet .
  var Q : Qid . var ATTS : AttrSet . var RS : RuleSet . var COND : Condition .
  var L : Label . var LL : LabelList .
  var CTX : SearchCtx .

  --- TODO : move to LABEL-LIST
  op getLabels : RuleSet -> LabelList .
  eq getLabels(rl T => T' [label(Q) ATTS] . RS) = labelElt(Q) getLabels(RS) .
  eq getLabels(crl T => T' if COND [label(Q) ATTS] . RS) = labelElt(Q) getLabels(RS) .
  eq getLabels(none) = nilLabel .

  op nbrs : Module Term LabelList SearchCtx Nat -> Set{QItem} .
  eq nbrs(M, T, nilLabel, CTX, N) = empty .
 ceq nbrs(M, T, (labelElt(Q) LL), CTX, N) = nbrs(M, T, LL, CTX, 0)
    if metaApply(M, T, Q, none, N) == failure .
 ceq nbrs(M, T, (labelElt(Q) LL), CTX, N)
   = [T', SC] ; nbrs(M, T, (labelElt(Q) LL), CTX, N + 1) 
    if T' := getTerm(metaApply(M, T, Q, none, N))
    /\ SC := score(downTerm(T,error), CTX) [owise] . --- FIXME: metaApply is called twice everytime! TODO: metaXApply

  op nbrs : Module Term SearchCtx -> Set{QItem} .
  eq nbrs(M,T,CTX) = nbrs(M, T, getLabels(getRls(M)), CTX, 0) .

  op insertAll : Set{QItem} LTree{QItem<=} -> LTree{QItem<=} .
  eq insertAll(empty, QUE) = QUE .
  eq insertAll(ITEM ; ITEMS, QUE) = insertAll(ITEMS, insert(ITEM, QUE)) .

  op checkSAT : Term Prop -> Bool .
  eq checkSAT(T,P) = downTerm(T,error) |= P .

  op search : Module Prop NeLTree{QItem<=} TermSet SearchCtx -> SearchResult .
 ceq search(M, P, NQUE, VIS, N)
    = if T in VIS
        then search(M, P, deleteMin(NQUE), VIS, N)
        else
          if checkSAT(T,P)
            then some(T,N)
            else search(M, P, insertAll(nbrs(M,T,N),deleteMin(NQUE)), (termElt(T) ; VIS), N + 1) --- FIXME: nbrs(M,T,ctx(N))
          fi
      fi
    if [T,SC] := findMin(NQUE) .
  eq search(M, P, QUE, VIS, N) = none(N) [owise] .

  op search : Module Term Prop -> SearchResult .
  eq search(M,T,P) = search(M, P, insert([T, default],empty), mtTerm, 0) .

  op getState : SearchResult -> [State] .
  eq getState(some(T,N)) = downTerm(T, error) .
  eq getState(none(N)) = error .
endfm
---load heuristic-search.maude
load q-item.maude

fmod TERM-SET is
  pr META-TERM .
  sort TermSet .

  var T : Term . var TS : TermSet .

  op termElt : Term -> TermSet [ctor] .
  op mtTerm : -> TermSet [ctor] .
  op _;_ : TermSet TermSet -> TermSet [ctor assoc comm id: mtTerm] .
  eq termElt(T) ; termElt(T) = termElt(T) .

  op _in_ : Term TermSet -> Bool .
  eq T in (termElt(T) ; TS) = true .
  eq T in TS = false [owise] .
endfm


fmod LABEL-LIST is
  pr META-MODULE .
  sort Label LabelList .
  subsort Label < LabelList .

  vars T T' : Term . var Q : Qid .
  var ATTS : AttrSet . var RS : RuleSet . var COND : Condition .

  op labelElt : Qid -> Label [ctor] .
  op nilLabel : -> LabelList [ctor] .
  op __ : LabelList LabelList -> LabelList [ctor assoc id: nilLabel] .

  op getLabels : RuleSet -> LabelList .
  eq getLabels(rl T => T' [label(Q) ATTS] . RS) = labelElt(Q) getLabels(RS) .
  eq getLabels(crl T => T' if COND [label(Q) ATTS] . RS) = labelElt(Q) getLabels(RS) .
  eq getLabels(none) = nilLabel .
endfm


fmod SEARCH is
  pr META-LEVEL .
  pr SCORE .
  pr TERM-SET .
  pr LEFTIST-TREES{QItem<=} .
  pr LIST{QItem} *
    (op __ : List{QItem} List{QItem} -> List{QItem} to _;_) .
  pr LABEL-LIST .

  vars M : Module .
  vars T T' : Term .
  var P : Prop .
  vars N N' : Nat .
  vars QUE : LTree{QItem<=} . vars NQUE : NeLTree{QItem<=} .
  vars SC SC' : Score .
  vars ITEM : QItem . vars ITEMS ITEMS' VIS : List{QItem} .
  ---var VIS : TermSet .
  var Q : Qid . var L : Label . var LL : LabelList .
  vars CTX CTX' : SearchCtx . var RT : Result4Tuple .
  var ACT : Act .
  var RES : SearchResult? .

  ---  module, current state, action label, ctx, sol num
  op nbrs : Module Term LabelList SearchCtx Nat -> List{QItem} .
  eq nbrs(M, T, nilLabel, CTX, N) = nil .
  eq nbrs(M, T, (labelElt(Q) LL), CTX, N) = nbrs(M, T, LL, CTX, 0) [owise] . --- metaXapply returns failure
 ceq nbrs(M, T, (labelElt(Q) LL), CTX, N)
    = [getTerm(RT), CTX', score(downTerm(T,error), act(Q,getSubstitution(RT)), CTX')]
      ; nbrs(M, T, (labelElt(Q) LL), CTX, N + 1)
    if RT := metaXapply(M, T, Q, none, 0, unbounded, N) /\
       ACT := act(Q,getSubstitution(RT)) /\
       CTX' := updateCtx(CTX,T,act(Q,none)) .

  ---  module, current state, ctx
  op nbrs : Module Term SearchCtx -> List{QItem} .
  eq nbrs(M,T,CTX) = nbrs(M, T, getLabels(getRls(M)), CTX, 0) .

  op insertAll : List{QItem} LTree{QItem<=} -> LTree{QItem<=} .
  eq insertAll(nil, QUE) = QUE .
  eq insertAll(ITEM ; ITEMS, QUE) = insertAll(ITEMS, insert(ITEM, QUE)) . ---[print "push"] .

  op checkSAT : Term Prop -> Bool .
  eq checkSAT(T,P) = downTerm(T,error) |= P .

  op visited : Term List{QItem} -> Bool .
  eq visited(T, ITEMS ; [T,CTX,SC] ; ITEMS') = true .
  eq visited(T, ITEMS) = false [owise] .

  sorts SearchResult SearchResult? .
  subsort SearchResult < SearchResult? .
  op some : QItem List{QItem} -> SearchResult [ctor] . --- c.e. found with ctx
  op none : List{QItem} -> SearchResult? [ctor] . --- c.e. not found with ctx

  op search : Module Prop NeLTree{QItem<=} List{QItem} -> SearchResult? .
 ceq search(M, P, NQUE, VIS)
    = if visited(T, VIS)
        then search(M, P, deleteMin(NQUE), VIS)
        else
          if checkSAT(T, P)
            then some([T,CTX,SC], VIS)
            else search(M, P, insertAll(ITEMS,deleteMin(NQUE)), ([T,CTX,SC] ; VIS))
          fi
      fi
    if [T,CTX,SC] := findMin(NQUE) /\
       ITEMS := nbrs(M,T,CTX) /\
       ST:[State] := downTerm(T, error) .
  eq search(M, P, QUE, VIS) = none(VIS) [owise] .

  op search : Module Term Prop -> SearchResult? .
  eq search(M,T,P) = search(M, P, insert([T, initCtx, default],empty), nil) .

  --- projection functions on SearchResult
  op $getTrace : QItem List{QItem} -> ResultTrace .
 ceq $getTrace([T,CTX,SC], ITEMS ; [T', CTX', SC'] ; ITEMS')
    = $getTrace([getParent(CTX), CTX', SC'], ITEMS') ===> state(downTerm(T,error)) 
    if T' = getParent(CTX) .
  eq $getTrace(ITEM, ITEMS) = nil [owise] . 

  op getTrace : SearchResult -> ResultTrace .
  eq getTrace(some(ITEM, ITEMS)) = $getTrace(ITEM, ITEMS) .

  op getNStates : SearchResult? -> Nat .
  eq getNStates(RES) = size(getVisited(RES)) .

  op getVisited : SearchResult? -> List{QItem} .
  eq getVisited(some(ITEM, ITEMS)) = ITEM ; ITEMS .
  eq getVisited(none(ITEMS)) = ITEMS .

  --- for debug
  op printSC : List{QItem} -> Bool .
  eq printSC([T, CTX, SC] ; ITEMS) = printSC(ITEMS) [print "score:" SC] .
  eq printSC(nil) = true .
endfm

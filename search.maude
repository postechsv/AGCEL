---load heuristic-search.maude
load q-item.maude

fmod TERM-SET is
  pr META-TERM .
  sort TermSet .

  var T : Term . var TS : TermSet .

  op termElt : Term -> TermSet [ctor] .
  op mtTerm : -> TermSet [ctor] .
  op _;_ : TermSet TermSet -> TermSet [ctor assoc comm id: mtTerm] .
  eq termElt(T) ; termElt(T) = termElt(T) .

  op _in_ : Term TermSet -> Bool .
  eq T in (termElt(T) ; TS) = true .
  eq T in TS = false [owise] .
endfm


fmod LABEL-LIST is
  pr META-MODULE .
  sort Label LabelList .
  subsort Label < LabelList .

  vars T T' : Term . var Q : Qid .
  var ATTS : AttrSet . var RS : RuleSet . var COND : Condition .

  op labelElt : Qid -> Label [ctor] .
  op nilLabel : -> LabelList [ctor] .
  op __ : LabelList LabelList -> LabelList [ctor assoc id: nilLabel] .

  op getLabels : RuleSet -> LabelList .
  eq getLabels(rl T => T' [label(Q) ATTS] . RS) = labelElt(Q) getLabels(RS) .
  eq getLabels(crl T => T' if COND [label(Q) ATTS] . RS) = labelElt(Q) getLabels(RS) .
  eq getLabels(none) = nilLabel .
endfm


fmod SEARCH is
  pr META-LEVEL .
  pr SCORE .
  pr TERM-SET .
  pr LEFTIST-TREES{QItem<=} .
  pr SET{QItem} *
    (op _,_ : Set{QItem} Set{QItem} -> Set{QItem} to _;_) .
  pr LABEL-LIST .

  vars M : Module .
  vars T T' : Term .
  var P : Prop .
  vars N N' : Nat .
  vars QUE : LTree{QItem<=} . vars NQUE : NeLTree{QItem<=} .
  vars SC : Score .
  vars ITEM : QItem . vars ITEMS : Set{QItem} .
  var VIS : TermSet .
  var Q : Qid . var L : Label . var LL : LabelList .
  vars CTX CTX' : SearchCtx . var RT : Result4Tuple .
  var ACT : Act .

  ---  module, current state, action label, ctx, sol num
  op nbrs : Module Term LabelList SearchCtx Nat -> Set{QItem} .
  eq nbrs(M, T, nilLabel, CTX, N) = empty .
  eq nbrs(M, T, (labelElt(Q) LL), CTX, N) = nbrs(M, T, LL, CTX, 0) [owise] . --- metaXapply returns failure
 ceq nbrs(M, T, (labelElt(Q) LL), CTX, N)
    = [getTerm(RT), CTX', score(downTerm(T,error), act(Q,getSubstitution(RT)), CTX')]
      ; nbrs(M, T, (labelElt(Q) LL), CTX, N + 1)
    if RT := metaXapply(M, T, Q, none, 0, unbounded, N) /\
       ACT := act(Q,getSubstitution(RT)) /\
       CTX' := updateCtx(CTX,T,ACT) .

  ---  module, current state, ctx
  op nbrs : Module Term SearchCtx -> Set{QItem} .
  eq nbrs(M,T,CTX) = nbrs(M, T, getLabels(getRls(M)), CTX, 0) .

  op insertAll : Set{QItem} LTree{QItem<=} -> LTree{QItem<=} .
  eq insertAll(empty, QUE) = QUE .
  eq insertAll(ITEM ; ITEMS, QUE) = insertAll(ITEMS, insert(ITEM, QUE)) . ---[print "push"] .

  op checkSAT : Term Prop -> Bool .
  eq checkSAT(T,P) = downTerm(T,error) |= P .

  op search : Module Prop NeLTree{QItem<=} TermSet Nat -> SearchResult .
 ceq search(M, P, NQUE, VIS, N)
    = if T in VIS
        then search(M, P, deleteMin(NQUE), VIS, N)
        else
          if checkSAT(T,P)
            then some(T,CTX,N)
            else search(M, P, insertAll(ITEMS,deleteMin(NQUE)), (termElt(T) ; VIS), N + | ITEMS |)
          fi
      fi
    if [T,CTX,SC] := findMin(NQUE) /\
       ITEMS := nbrs(M,T,CTX) /\
       ST:[State] := downTerm(T, error) 
       [print "pop " CTX "\n" ST:[State]] .
  eq search(M, P, QUE, VIS, N) = none [owise] .

  op search : Module Term Prop -> SearchResult .
  eq search(M,T,P) = search(M, P, insert([T, initCtx, default],empty), mtTerm, 0) .

  --- op getTrace : SearchResult Set{QItem} -> ...
endfm
